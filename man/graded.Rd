% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graded.R
\name{graded}
\alias{graded}
\alias{pass}
\alias{fail}
\alias{pass_if_equal}
\alias{fail_if_equal}
\alias{pass_if}
\alias{fail_if}
\title{Signal a final grade for a student's submission}
\usage{
graded(correct, message = NULL, ..., type = NULL, location = NULL)

pass(
  message = getOption("gradethis.pass", "Correct!"),
  ...,
  env = parent.frame()
)

fail(
  message = getOption("gradethis.fail", "Incorrect"),
  ...,
  env = parent.frame(),
  hint = getOption("gradethis.fail.hint", FALSE)
)

pass_if_equal(
  y = rlang::missing_arg(),
  message = getOption("gradethis.pass", "Correct!"),
  x = rlang::missing_arg(),
  ...,
  env = parent.frame()
)

fail_if_equal(
  y,
  message = getOption("gradethis.fail", "Incorrect"),
  x = rlang::missing_arg(),
  ...,
  env = parent.frame(),
  hint = getOption("gradethis.fail.hint", FALSE)
)

pass_if(cond, message = NULL, ..., env = parent.frame(), x = deprecated())

fail_if(
  cond,
  message = NULL,
  ...,
  env = parent.frame(),
  hint = getOption("gradethis.fail.hint", FALSE),
  x = deprecated()
)
}
\arguments{
\item{correct}{A logical value of whether or not the checked code is correct.}

\item{message}{A character string of the message to be displayed.}

\item{...}{Additional arguments passed to \code{graded()} or otherwise ignored.
Ignored by \code{pass_if()} and \code{fail_if()}.}

\item{type, location}{The \code{type} and \code{location} of the feedback object
provided to \pkg{learnr}. See
\url{https://rstudio.github.io/learnr/exercises.html#Custom_checking} for more
details.

\code{type} may be one of "auto", "success", "info", "warning", "error", or
"custom".

\code{location} may be one of "append", "prepend", or "replace".}

\item{env}{environment to evaluate the glue \code{message}. Most users of
\pkg{gradethis} will not need to use this argument.}

\item{hint}{Include a code feedback hint with the failing message? This
argument only applies to \code{fail()} and \code{fail_if_equal()} and the message is
added using the default options of \code{\link[=give_code_feedback]{give_code_feedback()}} and
\code{\link[=maybe_code_feedback]{maybe_code_feedback()}}. The default value of \code{hint} can be set using
\code{\link[=gradethis_setup]{gradethis_setup()}} or the \code{gradethis.fail.hint} option.}

\item{y}{The expected value against which \code{x} is compared using
\code{waldo::compare(x, y)}. In \code{pass_if_equal()}, if no value is provided, the
exercise \code{.solution}, or the result of evaluating the code in the
exercise's \verb{*-solution} chunk, will be used for the comparison.}

\item{x}{First item in the comparison. By default, when used inside
\code{\link[=grade_this]{grade_this()}}, \code{x} is automatically assigned the value of \code{.result} — in
other words the result of running the student's submitted code. \code{x} is not
the first argument since you will often want to compare the final value of
the student's submission against a specific value, \code{y}.}

\item{cond}{For \code{pass_if()} and \code{fail_if()}: A logical value or an expression
that will evaluate to a \code{TRUE} or \code{FALSE} value. If the value is \code{TRUE}, or
would be considered \code{TRUE} in an \verb{if (cond)} statement, then a passing or
failing grade is returned to the user.}
}
\value{
\itemize{
\item \code{pass()} and \code{pass_if_equal()} signal a \emph{correct} grade with a
glue-able \code{message}.
\item \code{fail()} and \code{fail_if_equal()} signal an \emph{incorrect} grade with a
glue-able \code{message}.
\item \code{pass_if()} and \code{fail_if()} signal a correct or incorrect grade if the
provided condition is \code{TRUE}, with a glue-able \code{message}.
\item \code{graded()} signals a correct or incorrect grade according to the logical
value of \code{correct}, with a standard character (unglued) \code{message}.
}
}
\description{
\code{graded()} is used to signal a final grade for a submission. Most likely,
you'll want to use its helper functions: \code{pass()}, \code{fail()},
\code{pass_if_equal()}, \code{fail_if_equal()}, \code{pass_if()} and \code{fail_if()}. When used
in \code{\link[=grade_this]{grade_this()}}, these functions signal a final grade and no further
checking of the student's submitted code is performed.
}
\section{Functions}{
\itemize{
\item \code{graded}: Prepare and signal a graded result.

\item \code{pass}: Signal a \emph{passing} grade.

\item \code{fail}: Signal a \emph{failing} grade.

\item \code{pass_if_equal}: Signal a \emph{passing} grade only if \code{x} and \code{y} are equal.

\item \code{fail_if_equal}: Signal a \emph{failing} grade only if \code{x} and \code{y} are equal.

\item \code{pass_if}: Pass if \code{cond} is \code{TRUE}.

\item \code{fail_if}: Fail if \code{cond} is \code{TRUE}.
}}

\section{Return a grade immediately}{


\code{graded()} and its helper functions are designed to short-circuit further
evaluation whenever they are called. If you're familiar with writing
functions in R, you can think of \code{graded()} (and \code{pass()}, \code{fail()}, etc.)
as a special version of \code{return()}.

The early return behavior can be helpful when you have to perform
complicated or long-running tests to determine if a student's code
submission is correct. We recommend that you perform the easiest tests
first, progressing to the most complicated tests. By taking advantage of
early grade returns, you can simplify your checking code:\preformatted{```\{r\}
grade_this(\{
  # is the answer a tibble?
  if (!inherits(.result, "tibble")) \{
    fail("Your answer should be a tibble.")
  \}
  
  # from now on we know that .result is a tibble...
  if (nrow(.result) == 5) \{
    fail("Your table should have 5 rows")
  \}
  
  # ...and it has 5 rows
  if (.result[[1]][[5]] != 5) \{
    fail("The value of the 5th row of the 1st column should be 5.")
  \}
  
  # all of the above checks have passed now.
  pass()
\})
```
}

Notice that it's important to choose a final fall-back grade as the last
value in your \code{\link[=grade_this]{grade_this()}} checking code. This last value is the default
grade that will be given if the submission passes all other checks. If
you're using the standard \code{\link[=gradethis_setup]{gradethis_setup()}} and you call \code{pass()} or
\code{fail()} without arguments, \code{pass()} will return a random praising phrase
and \code{fail()} will return code feedback (if possible) with an encouraging
phrase.
}

\section{Usage in \code{gradethis_exercise_checker()}}{


If \pkg{gradethis} is used in a \code{\link[learnr:tutorial]{learnr::tutorial()}} with the default
\code{\link[=gradethis_setup]{gradethis_setup()}}, \code{\link[=gradethis_exercise_checker]{gradethis_exercise_checker()}} expects the \verb{*-check}
chunk for an exercise to return a function. When the exercise submission is
to be graded, \code{\link[=gradethis_exercise_checker]{gradethis_exercise_checker()}} will call the checking
function, providing it with a consistent exercise submission environment —
see \code{\link[=mock_this_exercise]{mock_this_exercise()}} for examples of this environment. The goal of
this function is to evaluate the submission and to return a final grade via
\code{graded()}.

In general, tutorial authors should only use \code{graded()} and its helper
functions within \code{\link[=grade_this]{grade_this()}}. Whenever one of these functions is called
inside \code{\link[=grade_this]{grade_this()}}, the submission checking will stop immediately and
the appropriate grade and feedback will be returned.
}

\examples{
# Suppose our exercise asks the student to prepare and execute code that
# returns the value `42`. We'll use `grade_this()` to check their
# submission.
#
# Because we are demonstrating these functions inside R documentation, we'll
# save the function returned by `grade_this()` as `this_grader()`. Calling
# `this_grader()` on a mock exercise submission is equivalent to running the
# check code when the student clicks "Submit Answer" in a learnr tutorial.

this_grader <- 
# ```{r example-check}
  grade_this({
    # Automatically use .result to compare to an expected value
    pass_if_equal(42, "Great work!")
    
    # Similarly compare .result to an expected wrong value
    fail_if_equal(41, "You were so close!")
    fail_if_equal(43, "Oops, a little high there!")
    
    # or automatically pass if .result is equal to .solution
    pass_if_equal(message = "Great work!")
    
    # Be explicit if you need to round to avoid numerical accuracy issues
    pass_if_equal(x = round(.result), y = 42, "Close enough!")
    fail_if_equal(x = round(.result), y = 64, "Hmm, that's not right.")
    
    # For more complicated calculations, call pass() or fail()
    if (.result > 100) {
      fail("{.result} is way too high!")
    }
    if (.result * 100 == .solution) {
      pass("Right answer, but {.result} is two orders of magnitude too small.")
    }
    
    # Choose a default grade if none of the above have resulted in a grade
    fail()
  })
# ```

# Now lets try with a few different student submissions ----

# Correct!
this_grader(mock_this_exercise(.user_code = 42))

# These were close...
this_grader(mock_this_exercise(.user_code = 41))
this_grader(mock_this_exercise(.user_code = 43))

# Automatically use .solution if you have a *-solution chunk...
this_grader(mock_this_exercise(.user_code = 42, .solution_code = 42))

# Floating point arithmetic is tricky...
this_grader(mock_this_exercise(.user_code = 42.000001, .solution_code = 42))
this_grader(mock_this_exercise(.user_code = 64.123456, .solution_code = 42))

# Complicated checking situations...
this_grader(mock_this_exercise(.user_code = 101, .solution_code = 42))
this_grader(mock_this_exercise(.user_code = 0.42, .solution_code = 42))

# Finally fall back to the final answer...
this_grader(mock_this_exercise(.user_code = 33, .solution_code = 42))

}
